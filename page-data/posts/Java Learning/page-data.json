{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/Java Learning/","result":{"pageContext":{"currentCategory":"Java Learning","categories":["All","React Learning","Javascript Syntax","SQL Learning","Java Learning","Javascript Learning","Japanese News","blog"],"edges":[{"node":{"id":"481f9897-dedc-53f6-a56f-19734bae8924","excerpt":"상속(Inheritance) 상속은 기존에 정의된 클래스의 _속성(properties)_과 _기능(methods)_을 새로운 클래스에 재사용하는 것. 상속을 통해 코드의 재사용성을 높이고, 유지보수를 용이하게 하도록 함. 라는 키워드를 사용하여 상속을 구현한다. WHAT WHY FEATURE 자바프로그래밍에서의 상속 코드 1 B는 A를 상속하는 클래스이다. C1, C2는 B를 상속하는 클래스이다. 메인메소드 의 인스턴스를 만들고  (참조변수)에 할당했다. 의 멤버메소드인  호출했다.  클래스는 를 상속하므로 의 _멤버 변수_와 _멤버 메소드_를 호출할 수 있다. 코드 2 모든 포지션은 Player이다. SF, PF는 Forward이다. PG, SG는 Guard이다. 코드 3 SG, PF는 Player이다. 메인메소드 의 새로운 인스턴스가 에 참조되었다. 의 새로운 인스턴스가 에 참조되었다.  호출 의  _멤버 메소드_를 호출하였다.  호출 의  _멤버 메소드_를 호출하였다. 코드 …","fields":{"slug":"/a5093694-570b-443a-89ba-4341fc3cb1e3/"},"frontmatter":{"categories":"Java Learning","title":"Inheritance","date":"April 22, 2023"}},"next":{"fields":{"slug":"/96d8f60d-9283-4530-9057-d36e59552bb2/"}},"previous":{"fields":{"slug":"/5fd92d80-4ede-42f4-a15c-6f6f6fd73b06/"}}},{"node":{"id":"149ba741-7280-543b-b8dd-ea3a300e2eca","excerpt":"다형성(Polymorphism) 다형성은 하나의 인터페이스로부터 상속받은 여러 클래스들이 같은 메서드를 가지고 있을 때 각 클래스마다 다르게 구현된 메서드를 호출하는 기능. 즉, 같은 인터페이스를 가지면서도 각 클래스마다 다른 구현을 할 수 있도록 하는 기능이다. 자바에서는 _오버라이딩(overriding)_과 _오버로딩(overloading)_을 통해 다형성을 구현합니다. WHAT WHY FEATURE Visibility of a reference variable (참조변수의 가시성) Dynamic binding for an overrided method (오버라이딩된 메소드의 동적 바인딩) 자바프로그래밍에서의 다형성 코드 1 B는 A를 상속하는 클래스이다. 메인메소드 의 인스턴스를 만들고 형의 (참조변수)에 참조되었다. 의 멤버 변수인 를 호출하려고 하지만, 형에는 가 없어 호출 할 수 없다. 가시성 문제로 의 인스턴스이라도 형인 에서는 형의 멤버변수를 볼 수 없다.\n3. 형인…","fields":{"slug":"/96d8f60d-9283-4530-9057-d36e59552bb2/"},"frontmatter":{"categories":"Java Learning","title":"Polymorphism","date":"April 22, 2023"}},"next":{"fields":{"slug":"/895ab7fc-c726-44ac-bc2b-6d80b82b18b6/"}},"previous":{"fields":{"slug":"/a5093694-570b-443a-89ba-4341fc3cb1e3/"}}},{"node":{"id":"294329bb-508f-5f3f-a95e-93779429b585","excerpt":"“돈” ⬇️ 코드의 재활용 발전할수록 개발비용, 개발시간이 줄어든다. (인건비) 비 구조적언어 Machine Language 구조적언어 Flow Control Function 객체지향언어 (Object Oriented Programming Language) 비 구조적 언어 -> 구조적언어 -> 객체지향적언어 Machine Language + High-level 주석 + objective Class & Object  + compiler 변수 ➡️ 배열 (자료구조)  Inheritance   연산자  Modifier   흐름제어문  Polymorphism   함수  Abstraction     Interface     Exception Handling","fields":{"slug":"/895ab7fc-c726-44ac-bc2b-6d80b82b18b6/"},"frontmatter":{"categories":"Java Learning","title":"언어의 발전","date":"April 22, 2023"}},"next":{"fields":{"slug":"/671c6919-27e8-470f-a1f7-04796d24db62/"}},"previous":{"fields":{"slug":"/96d8f60d-9283-4530-9057-d36e59552bb2/"}}},{"node":{"id":"931b90b0-1e30-58ac-8b05-6a6b9a0927c5","excerpt":"상속을 위해 필요함. 그 객체에 대표하는 속성을 정의 (공통적인 부분을 위로 올리기 위해서) 클래스를 설계하기 위해서 Abstract 강제성 상속을 받는 클래스 또는 메서드를 반드시 구현하도록 하는 것. abstract 키워드가 위치하는 곳 클래스 메서드 추상화 클래스는 미완성된 클래스라서 An abstract class cannot be instantiated because it is meant to be a base class for other classes and cannot be used on its own. It is used to define a common interface or set of methods that must be implemented by its subclasses. An object cannot be created from an abstract class, but it can be used as a reference variable to hold an…","fields":{"slug":"/671c6919-27e8-470f-a1f7-04796d24db62/"},"frontmatter":{"categories":"Java Learning","title":"추상화","date":"April 22, 2023"}},"next":{"fields":{"slug":"/3a195c2b-2882-42b4-bab9-24b0db89b1d2/"}},"previous":{"fields":{"slug":"/895ab7fc-c726-44ac-bc2b-6d80b82b18b6/"}}},{"node":{"id":"12bed06f-a273-53e8-b3ed-763b807d6153","excerpt":"Class의 요소 Quiz 멤버 변수의 초기화 정적 변수의 사용 Overloading Function Class의 요소 , , … => Member Variable\n => Member Method\n => Constructer  키워드를 사용하여 새로운 객체를 만들어 낼 때,\n해당 클래스에 생성자를 호출해야 되어서\n=> 생성자에서 요구하는 arguments를 입력하지 않아서, 위 App 소스에서 에러가 걸렸다. 올바르게 객체를 생성 하려면 아래와 같이 짠다. Quiz Q1) 클래스와 오브젝트간의 관계는? 클래스는 같은 속성을 가진 것을 찍어내는 것. 오브젝트는 클래스에서 찍어나오는 것. Q2) Java에서 클래스를 정의하는 방법은? Q3) 클래스 내 구성요소는 변수 - 생명주기: 현재 위치하는 스코프 내 Member Variable (멤버 변수) - 위치하는 객체 내 메소드 Member Method (멤버 메소드) constructor (생성자) - 객체를 초기화 하기 위한 메소드(…","fields":{"slug":"/3a195c2b-2882-42b4-bab9-24b0db89b1d2/"},"frontmatter":{"categories":"Java Learning","title":"Object & Class","date":"April 22, 2023"}},"next":{"fields":{"slug":"/dd0a15ea-0cca-4194-9253-82c3d82d1911/"}},"previous":{"fields":{"slug":"/671c6919-27e8-470f-a1f7-04796d24db62/"}}},{"node":{"id":"a20e6f33-a2c6-57e2-9a77-a662c19be24a","excerpt":"접근 제어자 종류 접근 지정자에는 4가지가 있다. public: 모든 접근을 허용합니다. 어떠한 클래스가 접근을 하든 모두 허용됩니다. protected: 상속받은 클래스 또는 같은 패키지에서만 접근이 가능합니다. default: 기본 제헌자로써 아무것도 붙지 않고, 자신 클래스 내부와 같은 패키지에서만 접근이 가능하다. private: 외부에서 접근이 불가능하다. 즉 같은 클래스 내에서만 접근이 가능하다. 접근 제한의 정도 한정자 클래스 내부 동일 패키지 하위 클래스(상속) 그 외의 영역 public O O O O protected O O O X default O O X X private O X X X private private 지시자를 사용하여 그 멤버에 접근하는 예제 🙋‍♂️해설: private 지시자를 사용하면 해당 멤버는 외부에서 접근이 불가능하기 때문이다. 오로지 해당 클래스 내에서만 접근이 가능하다. 그래서 에러가 발생하였다. default default 지시자를 사용한 …","fields":{"slug":"/dd0a15ea-0cca-4194-9253-82c3d82d1911/"},"frontmatter":{"categories":"Java Learning","title":"Access Modifier","date":"April 22, 2023"}},"next":{"fields":{"slug":"/93748b6a-6c89-4ea0-ac8e-9f2c7af1f375/"}},"previous":{"fields":{"slug":"/3a195c2b-2882-42b4-bab9-24b0db89b1d2/"}}},{"node":{"id":"0348687b-e275-5ceb-8007-350e635979ad","excerpt":"예외 처리(Exception Handling)  Happy Scenario에서 벗어나는 경우 (비정상적인 종료 또는 데이터처리에 문제가 생기는 경우),\n예외 처리를 해주어야 한다. 기존 구조적언어에서는 flow control를 사용하여 예외를 처리하였다.\n예측되는 예외들을 모두 흐름제어문으로 처리하면, Happy Scenraio에서 코드가 훨씬 늘어나게 되었다.\nHappy Scenario와 예외처리하는 구문이 서로 섞여 있었다. → 가독성이 구리다. 이를 해결하는 것이 - WHAT WHY FEATURE Exception, Error 예외 클래스는 크게 두 그룹으로 나뉜다. Unchecked Checked 반드시 예외처리 구문이 필요하다. 호출한 부분에서 예외 객체를 받으려면 예외를 선언하는 부분에서 throw를 해줘야 한다. (throws)\n메서드 옆에 throws를 붙여 사용한다. 기존 구조적 언어에서의 예외처리 코드 1 JAVA프로그래밍에서 예외처리 코드 1 코드 2","fields":{"slug":"/93748b6a-6c89-4ea0-ac8e-9f2c7af1f375/"},"frontmatter":{"categories":"Java Learning","title":"Exception Handling","date":"April 22, 2023"}},"next":{"fields":{"slug":"/d9de9f9c-8c81-45a2-b04c-242f5f8fadd3/"}},"previous":{"fields":{"slug":"/dd0a15ea-0cca-4194-9253-82c3d82d1911/"}}},{"node":{"id":"e99593cc-85a6-5ab2-bdb3-d469ecc858b4","excerpt":"인터페이스란? 접점, 창구, 접속기\n정보를 주고받을 수 있는 창구\nBracket\n서로 다른 객체와 객체가 붙여야 할 때 인터페이스를 감싸서 사용. 특징 생성자가 없다.\n인터페이스에서는 추상 메서드를 주로 사용한다.\n클래스와 다르게 다중상속이 가능하다.\n클래스에 매달려서 사용이 된다.\n구현 메서드는 절대 가질 수 없다. 인터페이스의 선언법 interface  (extends  ) 인터페이스의 요소 (extends interface)는 생략가능 클래스 상수가 올수 있다. 추상 메서드가 올수 있다. default 메서드가 올수 있다. (Java 8이상) 클래스 메서드가 올수 있다. (Java 8이상) 추상 클래스와 인터페이스는 존재 목적이 다르다. 추상 클래스의 목적은,\n상속을 받아 기능을 이용하고, 확장시키는 데 있다. 예문 예문 1 예문 2 인터페이스는 브라켓이다.  모듈화된 클래스를 가져다가 쓸 수 있다.\n클래스는 모듈 (Engine)\n인터페이스는 브라켓 (Adaptor) 클래스끼…","fields":{"slug":"/d9de9f9c-8c81-45a2-b04c-242f5f8fadd3/"},"frontmatter":{"categories":"Java Learning","title":"Interface","date":"April 22, 2023"}},"next":{"fields":{"slug":"/9e63fbe5-d50a-4483-bcbb-670df91507a0/"}},"previous":{"fields":{"slug":"/93748b6a-6c89-4ea0-ac8e-9f2c7af1f375/"}}},{"node":{"id":"f99edb00-7347-56e2-981f-50215140571f","excerpt":"Interface features 추상 메서드만 가진다.  를 만들 수 없다. 클래스처럼 데이터 타입으로 사용될 수 있다.  키워드를 사용하여 클래스의 추상메서드를 구현시킨다.","fields":{"slug":"/9e63fbe5-d50a-4483-bcbb-670df91507a0/"},"frontmatter":{"categories":"Java Learning","title":"interface","date":"April 22, 2023"}},"next":{"fields":{"slug":"/7fa2310b-3196-4df0-ae85-57dd50eccf39/"}},"previous":{"fields":{"slug":"/d9de9f9c-8c81-45a2-b04c-242f5f8fadd3/"}}},{"node":{"id":"e71076a7-1510-5894-a040-88d6cc4d2c58","excerpt":"상속이란 객체 지향 프로그래밍에서,\n객체들 간의 관계를 구축하는 방법이다. 기존의 클래스로부터 속성과 동작을 상속받을 수 있다. 상속의 장점 코드의 재사용성을 높일 수 있다. 프로그램의 구조를 더욱 직관적으로 파악할 수 있다. 코드의 중복을 줄여, 유지보수가 용이해진다. 상속의 주의점 상위 클래스에서 변경이 일어나면 하위 클래스에서도 동시에 변경사항이 적용된다. 클래스간의 의존성이 높아져서 코드의 복잡도가 높아질 수 있다. 상속의 예 부모 자식 자식의 자식 학생 대학생  물건 책 전자책 차량 승용차  상속과 생성자 자식클래스가 생성될 때 부모 생성자가 호출된다. 이 때 지정(명시적호출)하지 않으면 default 생성자가 묵시적으로 호출된다.","fields":{"slug":"/7fa2310b-3196-4df0-ae85-57dd50eccf39/"},"frontmatter":{"categories":"Java Learning","title":"Inheritance","date":"April 22, 2023"}},"next":{"fields":{"slug":"/75aa672b-6d21-49e3-9627-948548f32f89/"}},"previous":{"fields":{"slug":"/9e63fbe5-d50a-4483-bcbb-670df91507a0/"}}},{"node":{"id":"4bd84cda-cb5f-567f-b454-0c4a8985bfe3","excerpt":"생성자 객체를 생성할 때 호출되는 특별한 메소드이다. 객체를 초기화하고 필요한 초기값을 설정하는 역할을 한다. 특징 생성자는 클래스 이름과 동일 반환 값이 없다. 객체가 생성될 때 자동으로 호출된다. 객체를 초기화하고 필요한 초기값을 설정하는 역할을 한다. 모든 클래스에 반드시 1개 이상 존재한다. 개발자가 구현해주지 않으면 Java가 기본으로 자동 생성해준다. 매개변수가 없는 생성자는  라고 부른다. 여러개의 경우는 오버로딩으로, 매개변수를 받아 초기화하는 방법이 달라질 수 있다.","fields":{"slug":"/75aa672b-6d21-49e3-9627-948548f32f89/"},"frontmatter":{"categories":"Java Learning","title":"Constructor","date":"April 22, 2023"}},"next":{"fields":{"slug":"/782c05c8-c8af-463a-9efe-49744037d6e5/"}},"previous":{"fields":{"slug":"/7fa2310b-3196-4df0-ae85-57dd50eccf39/"}}},{"node":{"id":"d7910a84-c0c9-5dbf-9587-6aed03d0cfc9","excerpt":"자바에서 접근 제어자(Access Modifier)란 클래스, 메서드, 변수 등의 멤버에 대한 외부에서의 접근 가능 여부를 결정하는 키워드다. 자바에서는 4개의 제어자가 있다.  해당 멤버는 어디서든 접근 가능합니다. 다른 패키지에서도 접근이 가능합니다.  해당 멤버는 동일한 패키지 내에서는 어디서든 접근 가능합니다. 다른 패키지에서는 해당 멤버를 상속받은 자식 클래스에서만 접근이 가능합니다. 모든 클래스가 상속 관계를 갖지 않는다는 점에서, protected 제어자를 전혀 사용하지 않아도 무방합니다. 다만 상속을 고려한 클래스 디자인을 할 때, 이를 이해하고 사용하면 코드의 가독성과 유지보수성이 향상될 수 있습니다. 따라서 protected 접근 제어자는 상황에 따라서 적절하게 사용되어야 합니다.  (아무 제어자도 붙이지 않은 경우) 해당 멤버는 동일한 패키지 내에서만 접근 가능합니다. 다른 패키지에서는 접근이 불가능합니다.  해당 멤버는 선언된 클래스 내에서만 접근 가능합니다.…","fields":{"slug":"/271d8051-b925-4146-9e6b-9eb5526b790c/"},"frontmatter":{"categories":"Java Learning","title":"Access Modifier","date":"March 16, 2023"}},"next":{"fields":{"slug":"/a8c47479-6884-4f33-aa39-8ca1ce57fcaf/"}},"previous":{"fields":{"slug":"/8fbb96b3-9995-4682-b99c-4b6234ae9749/"}}},{"node":{"id":"5128df38-d74d-5d53-b2dc-802c1449311d","excerpt":"OOP Object Oriented Programming ↕️ Procedural Programming features Abstraction Encapsulation Inheritance Polymorphism Information hiding 메소드 클래스(참조형)에서 특정한 기능을 수행하는 코드이다. 함수와 비슷한 역할을 하지만,\n메소드는 클래스 내의 멤버들의 값을 처리하기 위해 사용되는 함수이다. 따라서, 메소드는 클래스에 속한 함수라고 생각할 수 있다. 함수는 독립적으로 존재할 수 있지만, 메소드는 반드시 클래스에 속해 있어야 한다. 예시코드 Type casting 타입 형 변환 Widening Casting 묵시적 형변환 작은 유형을 큰 유형 크기로 변환하기  →  →  →  →  →   →  → … Narrowing Casting 명시적 형변환 큰 유형을 작은 유형으로 변환하기  →  →  →  →  →  →  메소드 오버로딩 같은 이름을 가지는 메소드를 중복하여 정의하는…","fields":{"slug":"/5dada8f9-42ac-4373-a599-bfa5e1d3bfe3/"},"frontmatter":{"categories":"Java Learning","title":"Class Object","date":"March 06, 2023"}},"next":{"fields":{"slug":"/31b4f755-ca66-40b6-9980-2a49bb46a89a/"}},"previous":{"fields":{"slug":"/826e42ec-4ae1-4655-a5cd-c69703faf48a/"}}},{"node":{"id":"fc81981d-2050-5de2-835a-a7a3d415a083","excerpt":"기본형 (Primitive Type) , , , ,  등 과 같은 것이 있다. 8가지 기본형 타입을 미리 정의하여 제공한다. 실제 값을 저장하는 공간으로 Stack 메모리에 저장 기본값이 존재하기 때문에 Null이 존재하지 안흔다. 기본형 타입에 Null을 넣고 싶다면 Reference 클래스를 활용한다. 정의할 떄 소문자를 사용한다. 참조형 (Reference Type) , , ,  등 과 같은 것이 있다. 기본형을 제외한 나머지 형이다. Null이 존재한다. Class는 대문자로 시작한다. 변수이름 지정   클래스 소스파일 일반적으로 1개의 클래스가 존재한다. 각각 하나의 클래스를 갖는다. 물론 하나의 자바소스코드에 여러개의 클래스가 정의 될 수 있다. 컴파일 소스파일을 로 변경해준다. CPU가 아닌 가상머신(JVM)에서 이해할 수 있는 코드이다. 이와 다르게 란. 바이너리 파일은 실행가능한 코드, 컴퓨터가 인식할 수 있는 0과 1로 구성된 이진코드를 의미한다.","fields":{"slug":"/31b4f755-ca66-40b6-9980-2a49bb46a89a/"},"frontmatter":{"categories":"Java Learning","title":"Java Basic","date":"March 06, 2023"}},"next":{"fields":{"slug":"/9c9a0ae8-c3ba-4334-b0b1-61b9861e9413/"}},"previous":{"fields":{"slug":"/5dada8f9-42ac-4373-a599-bfa5e1d3bfe3/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"],"slicesMap":{}}